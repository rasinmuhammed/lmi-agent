"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-equals/dist/esm/index.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/fast-equals/dist/esm/index.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nvar getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Combine two comparators into a single comparators.\n */ function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */ function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== \"object\" || typeof b !== \"object\") {\n            return areItemsEqual(a, b, state);\n        }\n        var cache = state.cache;\n        var cachedA = cache.get(a);\n        var cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        var result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */ function getShortTag(value) {\n    return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */ function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */ var hasOwn = Object.hasOwn || function(object, property) {\n    return hasOwnProperty.call(object, property);\n};\n/**\n * Whether the values passed are strictly equal or both NaN.\n */ function sameValueZeroEqual(a, b) {\n    return a === b || !a && !b && a !== a && b !== b;\n}\nvar PREACT_VNODE = \"__v\";\nvar PREACT_OWNER = \"__o\";\nvar REACT_OWNER = \"_owner\";\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys = Object.keys;\n/**\n * Whether the arrays are equal in value.\n */ function areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dates passed are equal in value.\n */ function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */ function areErrorsEqual(a, b) {\n    return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */ function areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */ function areMapsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.entries();\n    var aResult;\n    var bResult;\n    var index = 0;\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.entries();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            var aEntry = aResult.value;\n            var bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */ var areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */ function areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */ function areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */ function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */ function areSetsEqual(a, b, state) {\n    var size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    var matchedIndices = new Array(size);\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        var bIterable = b.values();\n        var hasMatch = false;\n        var matchIndex = 0;\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */ function areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */ function areUrlsEqual(a, b) {\n    return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\nvar ARGUMENTS_TAG = \"[object Arguments]\";\nvar BOOLEAN_TAG = \"[object Boolean]\";\nvar DATE_TAG = \"[object Date]\";\nvar ERROR_TAG = \"[object Error]\";\nvar MAP_TAG = \"[object Map]\";\nvar NUMBER_TAG = \"[object Number]\";\nvar OBJECT_TAG = \"[object Object]\";\nvar REG_EXP_TAG = \"[object RegExp]\";\nvar SET_TAG = \"[object Set]\";\nvar STRING_TAG = \"[object String]\";\nvar URL_TAG = \"[object URL]\";\nvar isArray = Array.isArray;\nvar isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView ? ArrayBuffer.isView : null;\nvar assign = Object.assign;\nvar getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */ function createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual, areDatesEqual = _a.areDatesEqual, areErrorsEqual = _a.areErrorsEqual, areFunctionsEqual = _a.areFunctionsEqual, areMapsEqual = _a.areMapsEqual, areNumbersEqual = _a.areNumbersEqual, areObjectsEqual = _a.areObjectsEqual, arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual, areRegExpsEqual = _a.areRegExpsEqual, areSetsEqual = _a.areSetsEqual, areTypedArraysEqual = _a.areTypedArraysEqual, areUrlsEqual = _a.areUrlsEqual, unknownTagComparators = _a.unknownTagComparators;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */ return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        var type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== \"object\") {\n            if (type === \"number\") {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === \"function\") {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        var constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n        // capturing the string tag or comparing against all possible constructors.\n        if (isTypedArray != null && isTypedArray(a)) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        var tag = getTag(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== \"function\" && typeof b.then !== \"function\" && areObjectsEqual(a, b, state);\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        if (unknownTagComparators) {\n            var unknownTagComparator = unknownTagComparators[tag];\n            if (!unknownTagComparator) {\n                var shortTag = getShortTag(a);\n                if (shortTag) {\n                    unknownTagComparator = unknownTagComparators[shortTag];\n                }\n            }\n            // If the custom config has an unknown tag comparator that matches the captured tag or the\n            // @@toStringTag, it is the source of truth for whether the values are equal.\n            if (unknownTagComparator) {\n                return unknownTagComparator(a, b, state);\n            }\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */ function createEqualityComparatorConfig(_a) {\n    var circular = _a.circular, createCustomConfig = _a.createCustomConfig, strict = _a.strict;\n    var config = {\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n        unknownTagComparators: undefined\n    };\n    if (createCustomConfig) {\n        config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n        var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n        var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n        var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n        config = assign({}, config, {\n            areArraysEqual: areArraysEqual$1,\n            areMapsEqual: areMapsEqual$1,\n            areObjectsEqual: areObjectsEqual$1,\n            areSetsEqual: areSetsEqual$1\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */ function createInternalEqualityComparator(compare) {\n    return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */ function createIsEqual(_a) {\n    var circular = _a.circular, comparator = _a.comparator, createState = _a.createState, equals = _a.equals, strict = _a.strict;\n    if (createState) {\n        return function isEqual(a, b) {\n            var _a = createState(), _b = _a.cache, cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b, meta = _a.meta;\n            return comparator(a, b, {\n                cache: cache,\n                equals: equals,\n                meta: meta,\n                strict: strict\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals: equals,\n                meta: undefined,\n                strict: strict\n            });\n        };\n    }\n    var state = {\n        cache: undefined,\n        equals: equals,\n        meta: undefined,\n        strict: strict\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */ var deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */ var strictDeepEqual = createCustomEqual({\n    strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */ var circularDeepEqual = createCustomEqual({\n    circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */ var shallowEqual = createCustomEqual({\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */ var strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */ var circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    }\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */ var strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function() {\n        return sameValueZeroEqual;\n    },\n    strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */ function createCustomEqual(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _a = options.circular, circular = _a === void 0 ? false : _a, createCustomInternalComparator = options.createInternalComparator, createState = options.createState, _b = options.strict, strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n        circular: circular,\n        comparator: comparator,\n        createState: createState,\n        equals: equals,\n        strict: strict\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxzQkFBc0JDLE9BQU9ELG1CQUFtQixFQUFFRSx3QkFBd0JELE9BQU9DLHFCQUFxQjtBQUMxRyxJQUFJQyxpQkFBaUJGLE9BQU9HLFNBQVMsQ0FBQ0QsY0FBYztBQUNwRDs7Q0FFQyxHQUNELFNBQVNFLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXO0lBQ2hELE9BQU8sU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7UUFDL0IsT0FBT0wsWUFBWUcsR0FBR0MsR0FBR0MsVUFBVUosWUFBWUUsR0FBR0MsR0FBR0M7SUFDekQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxpQkFBaUJDLGFBQWE7SUFDbkMsT0FBTyxTQUFTQyxXQUFXTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztRQUNsQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsS0FBSyxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFVO1lBQzVELE9BQU9HLGNBQWNKLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsSUFBSUksUUFBUUosTUFBTUksS0FBSztRQUN2QixJQUFJQyxVQUFVRCxNQUFNRSxHQUFHLENBQUNSO1FBQ3hCLElBQUlTLFVBQVVILE1BQU1FLEdBQUcsQ0FBQ1A7UUFDeEIsSUFBSU0sV0FBV0UsU0FBUztZQUNwQixPQUFPRixZQUFZTixLQUFLUSxZQUFZVDtRQUN4QztRQUNBTSxNQUFNSSxHQUFHLENBQUNWLEdBQUdDO1FBQ2JLLE1BQU1JLEdBQUcsQ0FBQ1QsR0FBR0Q7UUFDYixJQUFJVyxTQUFTUCxjQUFjSixHQUFHQyxHQUFHQztRQUNqQ0ksTUFBTU0sTUFBTSxDQUFDWjtRQUNiTSxNQUFNTSxNQUFNLENBQUNYO1FBQ2IsT0FBT1U7SUFDWDtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRSxZQUFZQyxLQUFL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O0lBQ3hDLElBQUkzQyxLQUFLMkMsUUFBUTdCLFFBQVEsRUFBRUEsV0FBV2QsT0FBTyxLQUFLLElBQUksUUFBUUEsSUFBSTRDLGlDQUFpQ0QsUUFBUUosd0JBQXdCLEVBQUVWLGNBQWNjLFFBQVFkLFdBQVcsRUFBRUMsS0FBS2EsUUFBUTNCLE1BQU0sRUFBRUEsU0FBU2MsT0FBTyxLQUFLLElBQUksUUFBUUE7SUFDOU4sSUFBSWIsU0FBU0osK0JBQStCOEI7SUFDNUMsSUFBSXpDLGFBQWFILHlCQUF5QmtCO0lBQzFDLElBQUl4RixTQUFTbUgsaUNBQ1BBLCtCQUErQjFDLGNBQy9Cb0IsaUNBQWlDcEI7SUFDdkMsT0FBTzBCLGNBQWM7UUFBRWQsVUFBVUE7UUFBVVosWUFBWUE7UUFBWTJCLGFBQWFBO1FBQWFwRyxRQUFRQTtRQUFRdUYsUUFBUUE7SUFBTztBQUNoSTtBQUU2TSxDQUM3TSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sbWktYWdlbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZmFzdC1lcXVhbHMvZGlzdC9lc20vaW5kZXgubWpzPzEwZDciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKipcbiAqIENvbWJpbmUgdHdvIGNvbXBhcmF0b3JzIGludG8gYSBzaW5nbGUgY29tcGFyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb21wYXJhdG9ycyhjb21wYXJhdG9yQSwgY29tcGFyYXRvckIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvckEoYSwgYiwgc3RhdGUpICYmIGNvbXBhcmF0b3JCKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBXcmFwIHRoZSBwcm92aWRlZCBgYXJlSXRlbXNFcXVhbGAgbWV0aG9kIHRvIG1hbmFnZSB0aGUgY2lyY3VsYXIgc3RhdGUsIGFsbG93aW5nXG4gKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xuICogc3RhY2sgb3ZlcmZsb3dzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaXJjdWxhcihhLCBiLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgdHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuICAgICAgICB2YXIgY2FjaGVkQSA9IGNhY2hlLmdldChhKTtcbiAgICAgICAgdmFyIGNhY2hlZEIgPSBjYWNoZS5nZXQoYik7XG4gICAgICAgIGlmIChjYWNoZWRBICYmIGNhY2hlZEIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRBID09PSBiICYmIGNhY2hlZEIgPT09IGE7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KGEsIGIpO1xuICAgICAgICBjYWNoZS5zZXQoYiwgYSk7XG4gICAgICAgIHZhciByZXN1bHQgPSBhcmVJdGVtc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGEpO1xuICAgICAgICBjYWNoZS5kZWxldGUoYik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBgQEB0b1N0cmluZ1RhZ2Agb2YgdGhlIHZhbHVlLCBpZiBpdCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFNob3J0VGFnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnRpZXMgdG8gc3RyaWN0bHkgZXhhbWluZSwgd2hpY2ggaW5jbHVkZSBib3RoIG93biBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiBub3QgZW51bWVyYWJsZSBhbmQgc3ltYm9sIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmljdFByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIHByb3BlcnR5IHBhc3NlZCBhcyBhbiBvd24gcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd24gPSBPYmplY3QuaGFzT3duIHx8XG4gICAgKGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpO1xuICAgIH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSB2YWx1ZXMgcGFzc2VkIGFyZSBzdHJpY3RseSBlcXVhbCBvciBib3RoIE5hTi5cbiAqL1xuZnVuY3Rpb24gc2FtZVZhbHVlWmVyb0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCAoIWEgJiYgIWIgJiYgYSAhPT0gYSAmJiBiICE9PSBiKTtcbn1cblxudmFyIFBSRUFDVF9WTk9ERSA9ICdfX3YnO1xudmFyIFBSRUFDVF9PV05FUiA9ICdfX28nO1xudmFyIFJFQUNUX09XTkVSID0gJ19vd25lcic7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwga2V5cyA9IE9iamVjdC5rZXlzO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIHZhciBpbmRleCA9IGEubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5lcXVhbHMoYVtpbmRleF0sIGJbaW5kZXhdLCBpbmRleCwgaW5kZXgsIGEsIGIsIHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBkYXRlcyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVEYXRlc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEuZ2V0VGltZSgpLCBiLmdldFRpbWUoKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGVycm9ycyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVFcnJvcnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgICBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZSAmJlxuICAgICAgICBhLmNhdXNlID09PSBiLmNhdXNlICYmXG4gICAgICAgIGEuc3RhY2sgPT09IGIuc3RhY2spO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBmdW5jdGlvbnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlRnVuY3Rpb25zRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhID09PSBiO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBgTWFwYHMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVNYXBzRXF1YWwoYSwgYiwgc3RhdGUpIHtcbiAgICB2YXIgc2l6ZSA9IGEuc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlZEluZGljZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIGFJdGVyYWJsZSA9IGEuZW50cmllcygpO1xuICAgIHZhciBhUmVzdWx0O1xuICAgIHZhciBiUmVzdWx0O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKChhUmVzdWx0ID0gYUl0ZXJhYmxlLm5leHQoKSkpIHtcbiAgICAgICAgaWYgKGFSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJJdGVyYWJsZSA9IGIuZW50cmllcygpO1xuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFFbnRyeSA9IGFSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB2YXIgYkVudHJ5ID0gYlJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5lcXVhbHMoYUVudHJ5WzBdLCBiRW50cnlbMF0sIGluZGV4LCBtYXRjaEluZGV4LCBhLCBiLCBzdGF0ZSkgJiZcbiAgICAgICAgICAgICAgICBzdGF0ZS5lcXVhbHMoYUVudHJ5WzFdLCBiRW50cnlbMV0sIGFFbnRyeVswXSwgYkVudHJ5WzBdLCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG51bWJlcnMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG52YXIgYXJlTnVtYmVyc0VxdWFsID0gc2FtZVZhbHVlWmVyb0VxdWFsO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBrZXlzKGEpO1xuICAgIHZhciBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChrZXlzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnRpZXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZSB3aXRoIHN0cmljdCBwcm9wZXJ0eSBjaGVja2luZy5cbiAqL1xuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsU3RyaWN0KGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBnZXRTdHJpY3RQcm9wZXJ0aWVzKGEpO1xuICAgIHZhciBpbmRleCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgIGlmIChnZXRTdHJpY3RQcm9wZXJ0aWVzKGIpLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcHJvcGVydHk7XG4gICAgdmFyIGRlc2NyaXB0b3JBO1xuICAgIHZhciBkZXNjcmlwdG9yQjtcbiAgICAvLyBEZWNyZW1lbnRpbmcgYHdoaWxlYCBzaG93ZWQgZmFzdGVyIHJlc3VsdHMgdGhhbiBlaXRoZXIgaW5jcmVtZW50aW5nIG9yXG4gICAgLy8gZGVjcmVtZW50aW5nIGBmb3JgIGxvb3AgYW5kIHRoYW4gYW4gaW5jcmVtZW50aW5nIGB3aGlsZWAgbG9vcC4gRGVjbGFyYXRpdmVcbiAgICAvLyBtZXRob2RzIGxpa2UgYHNvbWVgIC8gYGV2ZXJ5YCB3ZXJlIG5vdCB1c2VkIHRvIGF2b2lkIGluY3VycmluZyB0aGUgZ2FyYmFnZVxuICAgIC8vIGNvc3Qgb2YgYW5vbnltb3VzIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgaWYgKCFpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NyaXB0b3JBID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsIHByb3BlcnR5KTtcbiAgICAgICAgZGVzY3JpcHRvckIgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoKGRlc2NyaXB0b3JBIHx8IGRlc2NyaXB0b3JCKSAmJlxuICAgICAgICAgICAgKCFkZXNjcmlwdG9yQSB8fFxuICAgICAgICAgICAgICAgICFkZXNjcmlwdG9yQiB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JBLmNvbmZpZ3VyYWJsZSAhPT0gZGVzY3JpcHRvckIuY29uZmlndXJhYmxlIHx8XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvckEuZW51bWVyYWJsZSAhPT0gZGVzY3JpcHRvckIuZW51bWVyYWJsZSB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JBLndyaXRhYmxlICE9PSBkZXNjcmlwdG9yQi53cml0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgcHJpbWl0aXZlIHdyYXBwZXJzIHBhc3NlZCBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWwoYS52YWx1ZU9mKCksIGIudmFsdWVPZigpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgcmVnZXhwcyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVSZWdFeHBzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbn1cbi8qKlxuICogV2hldGhlciB0aGUgYFNldGBzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlU2V0c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgdmFyIHNpemUgPSBhLnNpemU7XG4gICAgaWYgKHNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoZWRJbmRpY2VzID0gbmV3IEFycmF5KHNpemUpO1xuICAgIHZhciBhSXRlcmFibGUgPSBhLnZhbHVlcygpO1xuICAgIHZhciBhUmVzdWx0O1xuICAgIHZhciBiUmVzdWx0O1xuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgIGlmIChhUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiSXRlcmFibGUgPSBiLnZhbHVlcygpO1xuICAgICAgICB2YXIgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSAmJlxuICAgICAgICAgICAgICAgIHN0YXRlLmVxdWFscyhhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhUmVzdWx0LnZhbHVlLCBiUmVzdWx0LnZhbHVlLCBhLCBiLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYXNNYXRjaCA9IG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc01hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFR5cGVkQXJyYXkgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgdmFyIGluZGV4ID0gYS5sZW5ndGg7XG4gICAgaWYgKGIubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoYVtpbmRleF0gIT09IGJbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIFVSTCBpbnN0YW5jZXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVVcmxzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoYS5ob3N0bmFtZSA9PT0gYi5ob3N0bmFtZSAmJlxuICAgICAgICBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmXG4gICAgICAgIGEucHJvdG9jb2wgPT09IGIucHJvdG9jb2wgJiZcbiAgICAgICAgYS5wb3J0ID09PSBiLnBvcnQgJiZcbiAgICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgICAgYS51c2VybmFtZSA9PT0gYi51c2VybmFtZSAmJlxuICAgICAgICBhLnBhc3N3b3JkID09PSBiLnBhc3N3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlFcXVhbChhLCBiLCBzdGF0ZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoKHByb3BlcnR5ID09PSBSRUFDVF9PV05FUiB8fFxuICAgICAgICBwcm9wZXJ0eSA9PT0gUFJFQUNUX09XTkVSIHx8XG4gICAgICAgIHByb3BlcnR5ID09PSBQUkVBQ1RfVk5PREUpICYmXG4gICAgICAgIChhLiQkdHlwZW9mIHx8IGIuJCR0eXBlb2YpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc093bihiLCBwcm9wZXJ0eSkgJiZcbiAgICAgICAgc3RhdGUuZXF1YWxzKGFbcHJvcGVydHldLCBiW3Byb3BlcnR5XSwgcHJvcGVydHksIHByb3BlcnR5LCBhLCBiLCBzdGF0ZSkpO1xufVxuXG52YXIgQVJHVU1FTlRTX1RBRyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xudmFyIEJPT0xFQU5fVEFHID0gJ1tvYmplY3QgQm9vbGVhbl0nO1xudmFyIERBVEVfVEFHID0gJ1tvYmplY3QgRGF0ZV0nO1xudmFyIEVSUk9SX1RBRyA9ICdbb2JqZWN0IEVycm9yXSc7XG52YXIgTUFQX1RBRyA9ICdbb2JqZWN0IE1hcF0nO1xudmFyIE5VTUJFUl9UQUcgPSAnW29iamVjdCBOdW1iZXJdJztcbnZhciBPQkpFQ1RfVEFHID0gJ1tvYmplY3QgT2JqZWN0XSc7XG52YXIgUkVHX0VYUF9UQUcgPSAnW29iamVjdCBSZWdFeHBdJztcbnZhciBTRVRfVEFHID0gJ1tvYmplY3QgU2V0XSc7XG52YXIgU1RSSU5HX1RBRyA9ICdbb2JqZWN0IFN0cmluZ10nO1xudmFyIFVSTF9UQUcgPSAnW29iamVjdCBVUkxdJztcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbnZhciBpc1R5cGVkQXJyYXkgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XG4gICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXdcbiAgICA6IG51bGw7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbnZhciBnZXRUYWcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbi8qKlxuICogQ3JlYXRlIGEgY29tcGFyYXRvciBtZXRob2QgYmFzZWQgb24gdGhlIHR5cGUtc3BlY2lmaWMgZXF1YWxpdHkgY29tcGFyYXRvcnMgcGFzc2VkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IoX2EpIHtcbiAgICB2YXIgYXJlQXJyYXlzRXF1YWwgPSBfYS5hcmVBcnJheXNFcXVhbCwgYXJlRGF0ZXNFcXVhbCA9IF9hLmFyZURhdGVzRXF1YWwsIGFyZUVycm9yc0VxdWFsID0gX2EuYXJlRXJyb3JzRXF1YWwsIGFyZUZ1bmN0aW9uc0VxdWFsID0gX2EuYXJlRnVuY3Rpb25zRXF1YWwsIGFyZU1hcHNFcXVhbCA9IF9hLmFyZU1hcHNFcXVhbCwgYXJlTnVtYmVyc0VxdWFsID0gX2EuYXJlTnVtYmVyc0VxdWFsLCBhcmVPYmplY3RzRXF1YWwgPSBfYS5hcmVPYmplY3RzRXF1YWwsIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwgPSBfYS5hcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLCBhcmVSZWdFeHBzRXF1YWwgPSBfYS5hcmVSZWdFeHBzRXF1YWwsIGFyZVNldHNFcXVhbCA9IF9hLmFyZVNldHNFcXVhbCwgYXJlVHlwZWRBcnJheXNFcXVhbCA9IF9hLmFyZVR5cGVkQXJyYXlzRXF1YWwsIGFyZVVybHNFcXVhbCA9IF9hLmFyZVVybHNFcXVhbCwgdW5rbm93blRhZ0NvbXBhcmF0b3JzID0gX2EudW5rbm93blRhZ0NvbXBhcmF0b3JzO1xuICAgIC8qKlxuICAgICAqIGNvbXBhcmUgdGhlIHZhbHVlIG9mIHRoZSB0d28gb2JqZWN0cyBhbmQgcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgaXRlbXMgYXJlIHN0cmljdGx5IGVxdWFsLCBubyBuZWVkIHRvIGRvIGEgdmFsdWUgY29tcGFyaXNvbi5cbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVpdGhlciBvZiB0aGUgaXRlbXMgYXJlIG51bGxpc2ggYW5kIGZhaWwgdGhlIHN0cmljdGx5IGVxdWFsIGNoZWNrXG4gICAgICAgIC8vIGFib3ZlLCB0aGVuIHRoZXkgbXVzdCBiZSB1bmVxdWFsLlxuICAgICAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgICAgIGlmICh0eXBlICE9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZU51bWJlcnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmVGdW5jdGlvbnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIHByaW1pdGl2ZSB2YWx1ZSB0aGF0IGlzIG5vdCBzdHJpY3RseSBlcXVhbCwgaXQgbXVzdCBiZSB1bmVxdWFsLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGEuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIENoZWNrcyBhcmUgbGlzdGVkIGluIG9yZGVyIG9mIGNvbW1vbmFsaXR5IG9mIHVzZS1jYXNlOlxuICAgICAgICAvLyAgIDEuIENvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAocGxhaW4gb2JqZWN0LCBhcnJheSlcbiAgICAgICAgLy8gICAyLiBDb21tb24gZGF0YSB2YWx1ZXMgKGRhdGUsIHJlZ2V4cClcbiAgICAgICAgLy8gICAzLiBMZXNzLWNvbW1vbiBjb21wbGV4IG9iamVjdCB0eXBlcyAobWFwLCBzZXQpXG4gICAgICAgIC8vICAgNC4gTGVzcy1jb21tb24gZGF0YSB2YWx1ZXMgKHByb21pc2UsIHByaW1pdGl2ZSB3cmFwcGVycylcbiAgICAgICAgLy8gSW5oZXJlbnRseSB0aGlzIGlzIGJvdGggc3ViamVjdGl2ZSBhbmQgYXNzdW1wdGl2ZSwgaG93ZXZlclxuICAgICAgICAvLyB3aGVuIHJldmlld2luZyBjb21wYXJhYmxlIGxpYnJhcmllcyBpbiB0aGUgd2lsZCB0aGlzIG9yZGVyXG4gICAgICAgIC8vIGFwcGVhcnMgdG8gYmUgZ2VuZXJhbGx5IGNvbnNpc3RlbnQuXG4gICAgICAgIC8vIENvbnN0cnVjdG9ycyBzaG91bGQgbWF0Y2gsIG90aGVyd2lzZSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGZhbHNlIHBvc2l0aXZlc1xuICAgICAgICAvLyBiZXR3ZWVuIGNsYXNzIGFuZCBzdWJjbGFzcyBvciBjdXN0b20gb2JqZWN0IGFuZCBQT0pPLlxuICAgICAgICBpZiAoY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgaXNQbGFpbk9iamVjdGAgb25seSBjaGVja3MgYWdhaW5zdCB0aGUgb2JqZWN0J3Mgb3duIHJlYWxtLiBDcm9zcy1yZWFsbVxuICAgICAgICAvLyBjb21wYXJpc29ucyBhcmUgcmFyZSwgYW5kIHdpbGwgYmUgaGFuZGxlZCBpbiB0aGUgdWx0aW1hdGUgZmFsbGJhY2ssIHNvXG4gICAgICAgIC8vIHdlIGNhbiBhdm9pZCBjYXB0dXJpbmcgdGhlIHN0cmluZyB0YWcuXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgaXNBcnJheSgpYCB3b3JrcyBvbiBzdWJjbGFzc2VzIGFuZCBpcyBjcm9zcy1yZWFsbSwgc28gd2UgY2FuIGF2b2lkIGNhcHR1cmluZ1xuICAgICAgICAvLyB0aGUgc3RyaW5nIHRhZyBvciBkb2luZyBhbiBgaW5zdGFuY2VvZmAgY2hlY2suXG4gICAgICAgIGlmIChpc0FycmF5KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlQXJyYXlzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBpc1R5cGVkQXJyYXkoKWAgd29ya3Mgb24gYWxsIHBvc3NpYmxlIFR5cGVkQXJyYXkgY2xhc3Nlcywgc28gd2UgY2FuIGF2b2lkXG4gICAgICAgIC8vIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZyBvciBjb21wYXJpbmcgYWdhaW5zdCBhbGwgcG9zc2libGUgY29uc3RydWN0b3JzLlxuICAgICAgICBpZiAoaXNUeXBlZEFycmF5ICE9IG51bGwgJiYgaXNUeXBlZEFycmF5KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGZhc3QtcGF0aCBlcXVhbGl0eSBjaGVja3MgZm9yIG90aGVyIGNvbXBsZXggb2JqZWN0IHR5cGVzIGluIHRoZVxuICAgICAgICAvLyBzYW1lIHJlYWxtIHRvIGF2b2lkIGNhcHR1cmluZyB0aGUgc3RyaW5nIHRhZy4gU3RyaWN0IGVxdWFsaXR5IGlzIHVzZWRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBgaW5zdGFuY2VvZmAgYmVjYXVzZSBpdCBpcyBtb3JlIHBlcmZvcm1hbnQgZm9yIHRoZSBjb21tb25cbiAgICAgICAgLy8gdXNlLWNhc2UuIElmIHNvbWVvbmUgaXMgc3ViY2xhc3NpbmcgYSBuYXRpdmUgY2xhc3MsIGl0IHdpbGwgYmUgaGFuZGxlZFxuICAgICAgICAvLyB3aXRoIHRoZSBzdHJpbmcgdGFnIGNvbXBhcmlzb24uXG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZURhdGVzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlUmVnRXhwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBjdXN0b20gb2JqZWN0LCBjYXB0dXJlIHRoZSBzdHJpbmcgdGFnIHRvIGRldGVybWluZyBpdHMgdHlwZS5cbiAgICAgICAgLy8gVGhpcyBpcyByZWFzb25hYmx5IHBlcmZvcm1hbnQgaW4gbW9kZXJuIGVudmlyb25tZW50cyBsaWtlIHY4IGFuZCBTcGlkZXJNb25rZXkuXG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcoYSk7XG4gICAgICAgIGlmICh0YWcgPT09IERBVEVfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWZcbiAgICAgICAgLy8gdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IFJFR19FWFBfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlUmVnRXhwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBNQVBfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBTRVRfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlU2V0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBPQkpFQ1RfVEFHKSB7XG4gICAgICAgICAgICAvLyBUaGUgZXhjZXB0aW9uIGZvciB2YWx1ZSBjb21wYXJpc29uIGlzIGN1c3RvbSBgUHJvbWlzZWAtbGlrZSBjbGFzcyBpbnN0YW5jZXMuIFRoZXNlIHNob3VsZFxuICAgICAgICAgICAgLy8gYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyBzdGFuZGFyZCBgUHJvbWlzZWAgb2JqZWN0cywgd2hpY2ggbWVhbnMgc3RyaWN0IGVxdWFsaXR5LCBhbmQgaWZcbiAgICAgICAgICAgIC8vIGl0IHJlYWNoZXMgdGhpcyBwb2ludCB0aGVuIHRoYXQgc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb24gaGFzIGFscmVhZHkgZmFpbGVkLlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgYS50aGVuICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGIudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgVVJMIHRhZywgaXQgc2hvdWxkIGJlIHRlc3RlZCBleHBsaWNpdGx5LiBMaWtlIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdFxuICAgICAgICAvLyBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IFVSTF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVVcmxzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGVycm9yIHRhZywgaXQgc2hvdWxkIGJlIHRlc3RlZCBleHBsaWNpdGx5LiBMaWtlIFJlZ0V4cCwgdGhlIHByb3BlcnRpZXMgYXJlIG5vdFxuICAgICAgICAvLyBlbnVtZXJhYmxlLCBhbmQgdGhlcmVmb3JlIHdpbGwgZ2l2ZSBmYWxzZSBwb3NpdGl2ZXMgaWYgdGVzdGVkIGxpa2UgYSBzdGFuZGFyZCBvYmplY3QuXG4gICAgICAgIGlmICh0YWcgPT09IEVSUk9SX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUVycm9yc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbiBhcmd1bWVudHMgdGFnLCBpdCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gQVJHVU1FTlRTX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgdGhlIHBlbnVsdGltYXRlIGZhbGxiYWNrLCBjaGVjayBpZiB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgcHJpbWl0aXZlIHdyYXBwZXJzLiBUaGlzXG4gICAgICAgIC8vIGlzIHZlcnkgcmFyZSBpbiBtb2Rlcm4gSlMsIHdoaWNoIGlzIHdoeSBpdCBpcyBkZXByaW9yaXRpemVkIGNvbXBhcmVkIHRvIGFsbCBvdGhlciBvYmplY3RcbiAgICAgICAgLy8gdHlwZXMuXG4gICAgICAgIGlmICh0YWcgPT09IEJPT0xFQU5fVEFHIHx8IHRhZyA9PT0gTlVNQkVSX1RBRyB8fCB0YWcgPT09IFNUUklOR19UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5rbm93blRhZ0NvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgICB2YXIgdW5rbm93blRhZ0NvbXBhcmF0b3IgPSB1bmtub3duVGFnQ29tcGFyYXRvcnNbdGFnXTtcbiAgICAgICAgICAgIGlmICghdW5rbm93blRhZ0NvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hvcnRUYWcgPSBnZXRTaG9ydFRhZyhhKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93blRhZ0NvbXBhcmF0b3IgPSB1bmtub3duVGFnQ29tcGFyYXRvcnNbc2hvcnRUYWddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXN0b20gY29uZmlnIGhhcyBhbiB1bmtub3duIHRhZyBjb21wYXJhdG9yIHRoYXQgbWF0Y2hlcyB0aGUgY2FwdHVyZWQgdGFnIG9yIHRoZVxuICAgICAgICAgICAgLy8gQEB0b1N0cmluZ1RhZywgaXQgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aCBmb3Igd2hldGhlciB0aGUgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgIGlmICh1bmtub3duVGFnQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmtub3duVGFnQ29tcGFyYXRvcihhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90IG1hdGNoaW5nIGFueSB0YWdzIHRoYXQgcmVxdWlyZSBhIHNwZWNpZmljIHR5cGUgb2YgY29tcGFyaXNvbiwgdGhlbiB3ZSBoYXJkLWNvZGUgZmFsc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgb25seSB0aGluZyByZW1haW5pbmcgaXMgc3RyaWN0IGVxdWFsaXR5LCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBhcmVkLiBUaGlzIGlzIGZvciBhIGZldyByZWFzb25zOlxuICAgICAgICAvLyAgIC0gQ2VydGFpbiB0eXBlcyB0aGF0IGNhbm5vdCBiZSBpbnRyb3NwZWN0ZWQgKGUuZy4sIGBXZWFrTWFwYCkuIEZvciB0aGVzZSB0eXBlcywgdGhpcyBpcyB0aGUgb25seVxuICAgICAgICAvLyAgICAgY29tcGFyaXNvbiB0aGF0IGNhbiBiZSBtYWRlLlxuICAgICAgICAvLyAgIC0gRm9yIHR5cGVzIHRoYXQgY2FuIGJlIGludHJvc3BlY3RlZCwgYnV0IHJhcmVseSBoYXZlIHJlcXVpcmVtZW50cyB0byBiZSBjb21wYXJlZFxuICAgICAgICAvLyAgICAgKGBBcnJheUJ1ZmZlcmAsIGBEYXRhVmlld2AsIGV0Yy4pLCB0aGUgY29zdCBpcyBhdm9pZGVkIHRvIHByaW9yaXRpemUgdGhlIGNvbW1vblxuICAgICAgICAvLyAgICAgdXNlLWNhc2VzIChtYXkgYmUgaW5jbHVkZWQgaW4gYSBmdXR1cmUgcmVsZWFzZSwgaWYgcmVxdWVzdGVkIGVub3VnaCkuXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkIGJ1dCBkbyBub3QgaGF2ZSBhbiBvYmplY3RpdmUgZGVmaW5pdGlvbiBvZiB3aGF0XG4gICAgICAgIC8vICAgICBlcXVhbGl0eSBpcyAoYEVycm9yYCwgZXRjLiksIHRoZSBzdWJqZWN0aXZlIGRlY2lzaW9uIGlzIHRvIGJlIGNvbnNlcnZhdGl2ZSBhbmQgc3RyaWN0bHkgY29tcGFyZS5cbiAgICAgICAgLy8gSW4gYWxsIGNhc2VzLCB0aGVzZSBkZWNpc2lvbnMgc2hvdWxkIGJlIHJlZXZhbHVhdGVkIGJhc2VkIG9uIGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIGFuZFxuICAgICAgICAvLyBjb21tb24gZGV2ZWxvcG1lbnQgcHJhY3RpY2VzLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB1c2VkIGZvciBidWlsZGluZyBjb21wYXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yQ29uZmlnKF9hKSB7XG4gICAgdmFyIGNpcmN1bGFyID0gX2EuY2lyY3VsYXIsIGNyZWF0ZUN1c3RvbUNvbmZpZyA9IF9hLmNyZWF0ZUN1c3RvbUNvbmZpZywgc3RyaWN0ID0gX2Euc3RyaWN0O1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIGFyZUFycmF5c0VxdWFsOiBzdHJpY3RcbiAgICAgICAgICAgID8gYXJlT2JqZWN0c0VxdWFsU3RyaWN0XG4gICAgICAgICAgICA6IGFyZUFycmF5c0VxdWFsLFxuICAgICAgICBhcmVEYXRlc0VxdWFsOiBhcmVEYXRlc0VxdWFsLFxuICAgICAgICBhcmVFcnJvcnNFcXVhbDogYXJlRXJyb3JzRXF1YWwsXG4gICAgICAgIGFyZUZ1bmN0aW9uc0VxdWFsOiBhcmVGdW5jdGlvbnNFcXVhbCxcbiAgICAgICAgYXJlTWFwc0VxdWFsOiBzdHJpY3RcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZU1hcHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxuICAgICAgICAgICAgOiBhcmVNYXBzRXF1YWwsXG4gICAgICAgIGFyZU51bWJlcnNFcXVhbDogYXJlTnVtYmVyc0VxdWFsLFxuICAgICAgICBhcmVPYmplY3RzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlT2JqZWN0c0VxdWFsLFxuICAgICAgICBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsOiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsLFxuICAgICAgICBhcmVSZWdFeHBzRXF1YWw6IGFyZVJlZ0V4cHNFcXVhbCxcbiAgICAgICAgYXJlU2V0c0VxdWFsOiBzdHJpY3RcbiAgICAgICAgICAgID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZVNldHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KVxuICAgICAgICAgICAgOiBhcmVTZXRzRXF1YWwsXG4gICAgICAgIGFyZVR5cGVkQXJyYXlzRXF1YWw6IHN0cmljdFxuICAgICAgICAgICAgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3RcbiAgICAgICAgICAgIDogYXJlVHlwZWRBcnJheXNFcXVhbCxcbiAgICAgICAgYXJlVXJsc0VxdWFsOiBhcmVVcmxzRXF1YWwsXG4gICAgICAgIHVua25vd25UYWdDb21wYXJhdG9yczogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgaWYgKGNyZWF0ZUN1c3RvbUNvbmZpZykge1xuICAgICAgICBjb25maWcgPSBhc3NpZ24oe30sIGNvbmZpZywgY3JlYXRlQ3VzdG9tQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgdmFyIGFyZUFycmF5c0VxdWFsJDEgPSBjcmVhdGVJc0NpcmN1bGFyKGNvbmZpZy5hcmVBcnJheXNFcXVhbCk7XG4gICAgICAgIHZhciBhcmVNYXBzRXF1YWwkMSA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZU1hcHNFcXVhbCk7XG4gICAgICAgIHZhciBhcmVPYmplY3RzRXF1YWwkMSA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZU9iamVjdHNFcXVhbCk7XG4gICAgICAgIHZhciBhcmVTZXRzRXF1YWwkMSA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZVNldHNFcXVhbCk7XG4gICAgICAgIGNvbmZpZyA9IGFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICBhcmVBcnJheXNFcXVhbDogYXJlQXJyYXlzRXF1YWwkMSxcbiAgICAgICAgICAgIGFyZU1hcHNFcXVhbDogYXJlTWFwc0VxdWFsJDEsXG4gICAgICAgICAgICBhcmVPYmplY3RzRXF1YWw6IGFyZU9iamVjdHNFcXVhbCQxLFxuICAgICAgICAgICAgYXJlU2V0c0VxdWFsOiBhcmVTZXRzRXF1YWwkMSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG59XG4vKipcbiAqIERlZmF1bHQgZXF1YWxpdHkgY29tcGFyYXRvciBwYXNzLXRocm91Z2gsIHVzZWQgYXMgdGhlIHN0YW5kYXJkIGBpc0VxdWFsYCBjcmVhdG9yIGZvclxuICogdXNlIGluc2lkZSB0aGUgYnVpbHQgY29tcGFyYXRvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IoY29tcGFyZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgX2luZGV4T3JLZXlBLCBfaW5kZXhPcktleUIsIF9wYXJlbnRBLCBfcGFyZW50Qiwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgYGlzRXF1YWxgIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGNvbnN1bWluZyBhcHBsaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXNFcXVhbChfYSkge1xuICAgIHZhciBjaXJjdWxhciA9IF9hLmNpcmN1bGFyLCBjb21wYXJhdG9yID0gX2EuY29tcGFyYXRvciwgY3JlYXRlU3RhdGUgPSBfYS5jcmVhdGVTdGF0ZSwgZXF1YWxzID0gX2EuZXF1YWxzLCBzdHJpY3QgPSBfYS5zdHJpY3Q7XG4gICAgaWYgKGNyZWF0ZVN0YXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBpc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IGNyZWF0ZVN0YXRlKCksIF9iID0gX2EuY2FjaGUsIGNhY2hlID0gX2IgPT09IHZvaWQgMCA/IGNpcmN1bGFyID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZCA6IF9iLCBtZXRhID0gX2EubWV0YTtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yKGEsIGIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgICAgICAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwge1xuICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICAgICAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgICAgICAgICAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIGNhY2hlOiB1bmRlZmluZWQsXG4gICAgICAgIGVxdWFsczogZXF1YWxzLFxuICAgICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCBzdGF0ZSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZS5cbiAqL1xudmFyIGRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKCk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uLlxuICovXG52YXIgc3RyaWN0RGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoeyBzdHJpY3Q6IHRydWUgfSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgZGVlcGx5LWVxdWFsIGluIHZhbHVlLCBpbmNsdWRpbmcgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGNpcmN1bGFyRGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoeyBjaXJjdWxhcjogdHJ1ZSB9KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbnZhciBzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBzdHJpY3Q6IHRydWUsXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUuXG4gKi9cbnZhciBzaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUgYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb25cbiAqL1xudmFyIHN0cmljdFNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBzdHJpY3Q6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICovXG52YXIgY2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzYW1lVmFsdWVaZXJvRXF1YWw7IH0sXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbnZhciBzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbDsgfSxcbiAgICBzdHJpY3Q6IHRydWUsXG59KTtcbi8qKlxuICogQ3JlYXRlIGEgY3VzdG9tIGVxdWFsaXR5IGNvbXBhcmlzb24gbWV0aG9kLlxuICpcbiAqIFRoaXMgY2FuIGJlIGRvbmUgdG8gY3JlYXRlIHZlcnkgdGFyZ2V0ZWQgY29tcGFyaXNvbnMgaW4gZXh0cmVtZSBob3QtcGF0aCBzY2VuYXJpb3NcbiAqIHdoZXJlIHRoZSBzdGFuZGFyZCBtZXRob2RzIGFyZSBub3QgcGVyZm9ybWFudCBlbm91Z2gsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHRvIHByb3ZpZGVcbiAqIHN1cHBvcnQgZm9yIGxlZ2FjeSBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBleHBlY3RlZCBmZWF0dXJlcyBsaWtlXG4gKiBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2Agb3V0IG9mIHRoZSBib3guXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUVxdWFsKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuY2lyY3VsYXIsIGNpcmN1bGFyID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIGNyZWF0ZUN1c3RvbUludGVybmFsQ29tcGFyYXRvciA9IG9wdGlvbnMuY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yLCBjcmVhdGVTdGF0ZSA9IG9wdGlvbnMuY3JlYXRlU3RhdGUsIF9iID0gb3B0aW9ucy5zdHJpY3QsIHN0cmljdCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgIHZhciBjb25maWcgPSBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWcob3B0aW9ucyk7XG4gICAgdmFyIGNvbXBhcmF0b3IgPSBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IoY29uZmlnKTtcbiAgICB2YXIgZXF1YWxzID0gY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yXG4gICAgICAgID8gY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yKGNvbXBhcmF0b3IpXG4gICAgICAgIDogY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IoY29tcGFyYXRvcik7XG4gICAgcmV0dXJuIGNyZWF0ZUlzRXF1YWwoeyBjaXJjdWxhcjogY2lyY3VsYXIsIGNvbXBhcmF0b3I6IGNvbXBhcmF0b3IsIGNyZWF0ZVN0YXRlOiBjcmVhdGVTdGF0ZSwgZXF1YWxzOiBlcXVhbHMsIHN0cmljdDogc3RyaWN0IH0pO1xufVxuXG5leHBvcnQgeyBjaXJjdWxhckRlZXBFcXVhbCwgY2lyY3VsYXJTaGFsbG93RXF1YWwsIGNyZWF0ZUN1c3RvbUVxdWFsLCBkZWVwRXF1YWwsIHNhbWVWYWx1ZVplcm9FcXVhbCwgc2hhbGxvd0VxdWFsLCBzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCwgc3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwsIHN0cmljdERlZXBFcXVhbCwgc3RyaWN0U2hhbGxvd0VxdWFsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0T3duUHJvcGVydHlOYW1lcyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwiY29tYmluZUNvbXBhcmF0b3JzIiwiY29tcGFyYXRvckEiLCJjb21wYXJhdG9yQiIsImlzRXF1YWwiLCJhIiwiYiIsInN0YXRlIiwiY3JlYXRlSXNDaXJjdWxhciIsImFyZUl0ZW1zRXF1YWwiLCJpc0NpcmN1bGFyIiwiY2FjaGUiLCJjYWNoZWRBIiwiZ2V0IiwiY2FjaGVkQiIsInNldCIsInJlc3VsdCIsImRlbGV0ZSIsImdldFNob3J0VGFnIiwidmFsdWUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImdldFN0cmljdFByb3BlcnRpZXMiLCJvYmplY3QiLCJjb25jYXQiLCJoYXNPd24iLCJwcm9wZXJ0eSIsImNhbGwiLCJzYW1lVmFsdWVaZXJvRXF1YWwiLCJQUkVBQ1RfVk5PREUiLCJQUkVBQ1RfT1dORVIiLCJSRUFDVF9PV05FUiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleXMiLCJhcmVBcnJheXNFcXVhbCIsImluZGV4IiwibGVuZ3RoIiwiZXF1YWxzIiwiYXJlRGF0ZXNFcXVhbCIsImdldFRpbWUiLCJhcmVFcnJvcnNFcXVhbCIsIm5hbWUiLCJtZXNzYWdlIiwiY2F1c2UiLCJzdGFjayIsImFyZUZ1bmN0aW9uc0VxdWFsIiwiYXJlTWFwc0VxdWFsIiwic2l6ZSIsIm1hdGNoZWRJbmRpY2VzIiwiQXJyYXkiLCJhSXRlcmFibGUiLCJlbnRyaWVzIiwiYVJlc3VsdCIsImJSZXN1bHQiLCJuZXh0IiwiZG9uZSIsImJJdGVyYWJsZSIsImhhc01hdGNoIiwibWF0Y2hJbmRleCIsImFFbnRyeSIsImJFbnRyeSIsImFyZU51bWJlcnNFcXVhbCIsImFyZU9iamVjdHNFcXVhbCIsInByb3BlcnRpZXMiLCJpc1Byb3BlcnR5RXF1YWwiLCJhcmVPYmplY3RzRXF1YWxTdHJpY3QiLCJkZXNjcmlwdG9yQSIsImRlc2NyaXB0b3JCIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCIsInZhbHVlT2YiLCJhcmVSZWdFeHBzRXF1YWwiLCJzb3VyY2UiLCJmbGFncyIsImFyZVNldHNFcXVhbCIsInZhbHVlcyIsImFyZVR5cGVkQXJyYXlzRXF1YWwiLCJhcmVVcmxzRXF1YWwiLCJob3N0bmFtZSIsInBhdGhuYW1lIiwicHJvdG9jb2wiLCJwb3J0IiwiaGFzaCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCIkJHR5cGVvZiIsIkFSR1VNRU5UU19UQUciLCJCT09MRUFOX1RBRyIsIkRBVEVfVEFHIiwiRVJST1JfVEFHIiwiTUFQX1RBRyIsIk5VTUJFUl9UQUciLCJPQkpFQ1RfVEFHIiwiUkVHX0VYUF9UQUciLCJTRVRfVEFHIiwiU1RSSU5HX1RBRyIsIlVSTF9UQUciLCJpc0FycmF5IiwiaXNUeXBlZEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJhc3NpZ24iLCJnZXRUYWciLCJ0b1N0cmluZyIsImJpbmQiLCJjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IiLCJfYSIsInVua25vd25UYWdDb21wYXJhdG9ycyIsImNvbXBhcmF0b3IiLCJ0eXBlIiwiY29uc3RydWN0b3IiLCJEYXRlIiwiUmVnRXhwIiwiTWFwIiwiU2V0IiwidGFnIiwidGhlbiIsInVua25vd25UYWdDb21wYXJhdG9yIiwic2hvcnRUYWciLCJjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3JDb25maWciLCJjaXJjdWxhciIsImNyZWF0ZUN1c3RvbUNvbmZpZyIsInN0cmljdCIsImNvbmZpZyIsImFyZUFycmF5c0VxdWFsJDEiLCJhcmVNYXBzRXF1YWwkMSIsImFyZU9iamVjdHNFcXVhbCQxIiwiYXJlU2V0c0VxdWFsJDEiLCJjcmVhdGVJbnRlcm5hbEVxdWFsaXR5Q29tcGFyYXRvciIsImNvbXBhcmUiLCJfaW5kZXhPcktleUEiLCJfaW5kZXhPcktleUIiLCJfcGFyZW50QSIsIl9wYXJlbnRCIiwiY3JlYXRlSXNFcXVhbCIsImNyZWF0ZVN0YXRlIiwiX2IiLCJXZWFrTWFwIiwibWV0YSIsImRlZXBFcXVhbCIsImNyZWF0ZUN1c3RvbUVxdWFsIiwic3RyaWN0RGVlcEVxdWFsIiwiY2lyY3VsYXJEZWVwRXF1YWwiLCJzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCIsInNoYWxsb3dFcXVhbCIsImNyZWF0ZUludGVybmFsQ29tcGFyYXRvciIsInN0cmljdFNoYWxsb3dFcXVhbCIsImNpcmN1bGFyU2hhbGxvd0VxdWFsIiwic3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwiLCJvcHRpb25zIiwiY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-equals/dist/esm/index.mjs\n");

/***/ })

};
;